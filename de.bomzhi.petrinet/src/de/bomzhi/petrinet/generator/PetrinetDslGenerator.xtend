/*
 * generated by Xtext
 */
package de.bomzhi.petrinet.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import de.bomzhi.petrinet.petrinetDsl.PetriNet
import de.bomzhi.petrinet.petrinetDsl.Transaction
import de.bomzhi.petrinet.petrinetDsl.AssureStatement
import de.bomzhi.petrinet.petrinetDsl.Place
import de.bomzhi.petrinet.petrinetDsl.Storage

class PetrinetDslGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		fsa.generateFile(resource.className+".scala", toJavaCode(resource.contents.head as PetriNet))
	}
	
	def className(Resource res) {
		var name = res.URI.lastSegment
		return name.substring(0, name.indexOf('.'))
	}
	
	def toJavaCode(PetriNet pn) '''
		package de.bomzhi.petrinetdsl
		
		object PetriNet extends App {
			ÇdefineAbstractClasses()È
			
			ÇdefineResourcesAndPlaces(pn)È
			
			ÇdefineMainLoop()È
		}
		
	'''
	
	
	def defineAbstractClasses() '''
		abstract class Resource(val label:String)
		
		case class Storage(val resource : Resource, 
						var count : Int, val capacity : Int)
						
		abstract class Place {
			val storages : List[Storage]
			override def toString = {
				def capacity(st:Storage)={
					if(st.capacity == 0) ".." else st.capacity
				}
				storages.foldLeft("")((text, st) => text+"['" + st.resource.label + "' " + st.count + "/" + capacity(st) + "]")
			}
		}
		
		abstract class Statement(val count : Int, val resource : Resource, val place : Place)
		
		case class Assure(override val count : Int, override val resource : Resource, override val place : Place) extends Statement(count, resource, place)
		case class Take(override val count : Int, override val resource : Resource, override val place : Place) extends Statement(count, resource, place)
		case class Put(override val count : Int, override val resource : Resource, override val place : Place) extends Statement(count, resource, place)
		
		class Transaction(name : String, statements: List[Statement]){
		    def isAlive : Boolean = {
				statements.forall((statement) => {
					val actStorage = statement.place.storages.find(_.resource == statement.resource).getOrElse(return false)
					statement match {
						case assure : Assure => if(assure.count == 0 ) actStorage.count == 0 else actStorage.count >= assure.count
						case take : Take => actStorage.count >= take.count
						case put : Put => actStorage.capacity == 0 || actStorage.capacity >= actStorage.count + put.count
					}
				})
			}
			def execute() {
				println("Executing transaction " + name)
				statements.foreach((statement) => {
					val actStorage = statement.place.storages.find(_.resource == statement.resource).get
					statement match {
						case take : Take => actStorage.count -= take.count
						case put : Put => actStorage.count += put.count
						case _ =>
					}
				})
			}
			override def toString = name
		}
				
	'''
	
	def defineResourcesAndPlaces(PetriNet pn) '''
		ÇFOR resource : pn.resourcesÈ
		object Çresource.nameÈ extends Resource("Çresource.nameÈ")
		ÇENDFORÈ
		ÇFOR place : pn.placesÈ
		object Çplace.nameÈ extends Place {
			val storages = 
				ÇFOR storage : place.storagesÈStorage(Çstorage.resourceRef.nameÈ, Çstorage.countÈ, Çstorage.capacityÈ)::ÇENDFORÈNil
		}
		ÇENDFORÈ
		val transactions = 
		ÇFOR transaction : pn.transactionsÈ
			new Transaction( "Çtransaction.nameÈ",
				ÇFOR statement : transaction.assureStatementsÈAssure(Çstatement.countÈ, Çstatement.resourceRef.nameÈ, Çstatement.placeRef.nameÈ) :: ÇENDFORÈ
				ÇFOR statement : transaction.takeStatementsÈTake(Çstatement.countÈ, Çstatement.resourceRef.nameÈ, Çstatement.placeRef.nameÈ) :: ÇENDFORÈ
				ÇFOR statement : transaction.putStatementsÈPut(Çstatement.countÈ, Çstatement.resourceRef.nameÈ, Çstatement.placeRef.nameÈ) :: ÇENDFORÈNil
			) ::
		ÇENDFORÈ
		Nil
		
		def printState() {
			ÇFOR place : pn.placesÈ
			println("Çplace.nameÈ: " + Çplace.nameÈ)
			ÇENDFORÈ
		}
	'''	
	
	def defineMainLoop()'''
		
		var lifeTr = transactions.filter(_.isAlive)

		while(!lifeTr.isEmpty){
			printState()
			println("Choose transaction:")
			lifeTr.foreach((tr) => println("" + (lifeTr.indexOf(tr)+1) + ". Transaction: " + tr))
			val input = readLine()
			try {
				val trIndex = input.toInt;
				lifeTr(trIndex-1).execute()
			} catch {
				case _ => println("Please enter correct transaction index!\n")
			}
			lifeTr = transactions.filter(_.isAlive)
		}
	'''
}
